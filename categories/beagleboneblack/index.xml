<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Beagleboneblack on ROBO LOG</title>
    <link>http://syundo0730.github.io/categories/beagleboneblack/</link>
    <description>Recent content in Beagleboneblack on ROBO LOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 17 Oct 2014 23:57:16 +0900</lastBuildDate>
    <atom:link href="http://syundo0730.github.io/categories/beagleboneblack/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Beagle Bone Blackにカメラを繋げてOpenCVで顔検出した</title>
      <link>http://syundo0730.github.io/post/1033/</link>
      <pubDate>Fri, 17 Oct 2014 23:57:16 +0900</pubDate>
      
      <guid>http://syundo0730.github.io/post/1033/</guid>
      <description>&lt;p&gt;Beagle Bone Blackの環境が整ったので次はカメラが使えるか試してみた．
そしてOpenCVで顔検出することを目指す．&lt;/p&gt;

&lt;p&gt;今回使うカメラはこれ．
&lt;a href=&#34;http://syundo0730.github.io/images/2014/10/2014-10-16-21.52.50.jpg&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-1036&#34; src=&#34;http://syundo0730.github.io/images/2014/10/2014-10-16-21.52.50.jpg&#34; alt=&#34;2014-10-16 21.52.50&#34;   /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大須のジャンク屋で売っていたもので，正体不明だったがとりあえず3個購入．1個800円．かなり古そうなので少なくともUVCには対応していないだろう．
何者か調べるためにUSBの情報を見てみる．&lt;/p&gt;
lsusb
ID 046d:08d9 Logitech, Inc. QuickCam IM/Connect

&lt;p&gt;どうやらこの製品らしい&lt;a href=&#34;https://support.logitech.com/en_us/product/222&#34;&gt;https://support.logitech.com/en_us/product/222&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;どんな画像が取れるのか試しに見てみる．&lt;/p&gt;
sudo apt-get install xawtv
xawtv -c /dev/video0

&lt;p&gt;&lt;a href=&#34;http://syundo0730.github.io/images/2014/10/92e3a3779139cfb20b6b014755961208.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-1037&#34; src=&#34;http://syundo0730.github.io/images/2014/10/92e3a3779139cfb20b6b014755961208.png&#34; alt=&#34;Screenshot from 2014-10-16 22^%11^%05&#34;   /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ロボットの目として使うには十分な画質はありそうだ．
ちなみにレンズ周りにあるリング部分でピント調節することができる．ジャンクだったためリングの動きが渋くて，なかなかピント調節の方法を見つけられなかった．&lt;/p&gt;

&lt;p&gt;さて次はBBBの上でOpenCVをビルドして使えるようにする．
OpenCV2.4.9のセットアップは大方このサイト&lt;a href=&#34;http://www.kkaneko.com/rinkou/opencv/opencvinstalllinux.html&#34;&gt;http://www.kkaneko.com/rinkou/opencv/opencvinstalllinux.html&lt;/a&gt;
の通りに進めた(執筆現在は最新の2.4.10のものに置き換わっている)．&lt;/p&gt;

&lt;p&gt;ただし，ダウンロードに時間がかかったり，エラーが出たりしたのでcmakeの部分は以下に変えた&lt;/p&gt;
cmake -DCMAKE_BUILD_TYPE=RELEASE -DWITH_TBB=ON -DWITH_GTK=ON -DWITH_OPENGL=ON -DWITH_OPENCL=OFF -DWITH_CUDA=OFF -DWITH_UNICAP=ON -DWITH_V4L=ON -DWITH_XINE=ON  .

&lt;p&gt;それでもBBB上では一連のセットアップに16時間程度かかった．もうどれだけ時間が掛かろうと寝るだけだったのでサンプル等一緒に入れておけばよかった．
サンプル画像が無いと不便なので母艦のOpenCV環境からコピーした．トホホ．&lt;/p&gt;
sudo scp -P 22 /usr/local/share/OpenCV/samples/c/*.png ubuntu@192.168.7.2:/usr/local/share/OpenCV/samples/c

&lt;p&gt;まずOpenCVからカメラが読めるか試してみる．以下のコードを使った．&lt;/p&gt;
// cam.cpp
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;
#include &lt;ctype.h&gt;

#ifndef CV_WINDOW_FREERATIO
#define CV_WINDOW_FREERATIO 0
#endif

int main( int argc, char **argv )
{
	cv::VideoCapture cap1(0);

	cap1.set( CV_CAP_PROP_FRAME_WIDTH, 320 );
	cap1.set( CV_CAP_PROP_FRAME_HEIGHT, 240 );

	cv::namedWindow(&#34;camera1&#34;, CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO);
	while ( 1 ) {
		cv::Mat img1;
		cap1 &gt;&gt; img1 ;
		cv::imshow(&#34;camera1&#34;, img1 );
		char ch = cv::waitKey(100);
		if ( ch == 27 ) break;
	}
	return 0;
}

&lt;p&gt;コンパイルする．&lt;/p&gt;
g++ -o cam.out cam.cpp -I/usr/local/include/opencv2 -I/usr/local/include/opencv -L/usr/local/lib -lopencv_core -lopencv_highgui

&lt;p&gt;これでカメラを読めることが確認できた．ただ残念ながらこのカメラを複数台同時に読み取ることはできなかった．&lt;/p&gt;

&lt;p&gt;次は顔検出をしてみる．こちらのサイト&lt;a href=&#34;http://unasuke.com/howto/2013/face-recognition-in-opencv/&#34;&gt;http://unasuke.com/howto/2013/face-recognition-in-opencv/&lt;/a&gt;のコードをほぼそのまま使わせていただいた．学習済みのデータとしてhaarcascade_frontalface_alt2.xmlを使った．&lt;/p&gt;
#include &lt;cv.h&gt;
#include &lt;highgui.h&gt;
#include &lt;ctype.h&gt;

#ifndef CV_WINDOW_FREERATIO
#define CV_WINDOW_FREERATIO 0
#endif

int main( int argc, char **argv )
{
	cv::VideoCapture cap1(0);

	cap1.set( CV_CAP_PROP_FRAME_WIDTH, 320 );
	cap1.set( CV_CAP_PROP_FRAME_HEIGHT, 240 );
	cv::namedWindow(&#34;camera1&#34;, CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO);
	std::string cascadeName = &#34;/usr/local/share/OpenCV/haarcascades/haarcascade_frontalface_alt2.xml&#34;;
	cv::CascadeClassifier cascade;
	if(!cascade.load(cascadeName)) return -1;
	double scale = 4.0;
	cv::Mat img, gray;

	while ( 1 ) {
		cap1 &gt;&gt; img;

		//Trans to glay scale
		cv::cvtColor(img, gray, CV_BGR2GRAY);
		cv::Mat smallImg(cv::saturate_cast&lt;int&gt;(img.rows/scale), cv::saturate_cast&lt;int&gt;(img.cols/scale), CV_8UC1);

		// 処理時間短縮のために画像を縮小
		cv::resize(gray, smallImg, smallImg.size(), 0, 0, cv::INTER_LINEAR);
		cv::equalizeHist( smallImg, smallImg);

		std::vector&lt;cv::Rect&gt; faces;
		/// マルチスケール（顔）探索xo
		// 画像，出力矩形，縮小スケール，最低矩形数，（フラグ），最小矩形

		cascade.detectMultiScale(smallImg, faces, 1.1, 2, CV_HAAR_SCALE_IMAGE, cv::Size(30, 30));

		// 結果の描画
		std::vector&lt;cv::Rect&gt;::const_iterator r = faces.begin();
		for(; r != faces.end(); ++r) {
			cv::Point center;
			int radius;
			center.x = cv::saturate_cast&lt;int&gt;((r-&gt;x + r-&gt;width*0.5)*scale);
			center.y = cv::saturate_cast&lt;int&gt;((r-&gt;y + r-&gt;height*0.5)*scale);
			radius = cv::saturate_cast&lt;int&gt;((r-&gt;width + r-&gt;height)*0.25*scale);
			cv::circle( img, center, radius, cv::Scalar(80,80,255), 3, 8, 0 );
		}
		cv::imshow(&#34;camera1&#34;, img );
		char ch = cv::waitKey(30);
		if ( ch == 27 ) break;
	}
	return 0;
}

&lt;p&gt;コンパイルする．&lt;/p&gt;
g++ -o facedetect.out facedetect.cpp -I/usr/local/include/opencv2 -I/usr/local/include/opencv -L/usr/local/lib -lopencv_core -lopencv_highgui -lopencv_imgproc -lopencv_objdetect

&lt;p&gt;こんな感じで顔を検出して赤い円を描画できた．
&lt;a href=&#34;http://syundo0730.github.io/images/2014/10/kao.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-1040&#34; src=&#34;http://syundo0730.github.io/images/2014/10/kao.png&#34; alt=&#34;kao&#34;   /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;メガネをかけていると蛍光灯の光の加減で認識が難しかった．メガネかけてる人の学習データも入れないといけない．
とりあえずメガネを取れば顔検出できた．&lt;/p&gt;

&lt;p&gt;おわり&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beagle Bone BlackにUbuntu14.04とデスクトップ環境をインストールした</title>
      <link>http://syundo0730.github.io/post/971/</link>
      <pubDate>Thu, 16 Oct 2014 21:42:07 +0900</pubDate>
      
      <guid>http://syundo0730.github.io/post/971/</guid>
      <description>&lt;p&gt;死蔵していたBeagle Bone Blackをやっと引っ張り出してきて，とりあえずUbuntuを入れてみたので作業のメモを残したい．BBB(Beagle Bone Blackのこと)のリビジョンはA5Aということで，いかに無駄に積まれていたのか察せられる．(在庫が無い時期で，わざわざ海外から共同購入したんだよなぁ…)&lt;/p&gt;

&lt;p&gt;まずGetting Started(&lt;a href=&#34;http://beagleboard.org/Getting%20Started&#34;&gt;http://beagleboard.org/Getting%20Started&lt;/a&gt;)に従ってみようとするも，そもそもBBBがUSBストレージとしてWindowsに認識されない．なぜだかわからないが，抜き差ししているとやっと認識された．それ以後は順調だった(?)．USBケーブルをつなげば仮想的にLANが繋がってる状態になるらしい．&lt;/p&gt;

&lt;p&gt;リビジョンが古いボードであるので，まずeMMCにあらかじめ書き込んであるAngstromのバージョンアップをしなければならない．
&lt;a href=&#34;http://beagleboard.org/latest-images&#34;&gt;http://beagleboard.org/latest-images&lt;/a&gt;
にある，Angstrom Distribution (BeagleBone Black - 2GB eMMC)
をmicroSDカードに書き込む．&lt;/p&gt;

&lt;p&gt;Angstromのイメージを書き込んだSDカードをBBBに挿入して差入口付近にあるboot用のボタンを押しながら電源を投入すると，4つのLEDが順番に点いていき一瞬4つ同時に光った後，ランダムに光るパターンになる．この状態のまま1時間程度放置する．書き換えが終われば再び4つのLEDが同時に点灯したままの状態になる．SDカードを抜いて電源を投入すれば，新しいImageで動くようになっている．&lt;/p&gt;

&lt;p&gt;以上はWindows上でもできる作業だが，後の作業はLinux環境から行うほうが都合がいい．
作業環境：VMware Player，64bit Ubuntu 14.04&lt;/p&gt;

&lt;p&gt;下準備が終わったら，次にUbuntuのboot用SDカードを作成する．
以下のサイトを参考にして作業を進める．
&lt;a href=&#34;http://elinux.org/BeagleBoardUbuntu&#34;&gt;http://elinux.org/BeagleBoardUbuntu&lt;/a&gt;&lt;/p&gt;
wget https://rcn-ee.net/deb/rootfs/trusty/ubuntu-14.04-console-armhf-2014-05-06.tar.xz
md5sum ubuntu-14.04-console-armhf-2014-05-06.tar.xz
tar xf ubuntu-14.04-console-armhf-2014-05-06.tar.xz
cd ubuntu-14.04-console-armhf-2014-05-06
sudo ./setup_sdcard.sh --probe-mmc

&lt;p&gt;以上でSDカードがどこにあるのか表示してくれるので，そこに書き込む&lt;/p&gt;
sudo ./setup_sdcard.sh --mmc /dev/sdX --uboot bone

&lt;p&gt;SDカードをBBBに挿入して電源を入れると，Ubuntuが起動するようになる．毎回bootボタンを押すべしと書いてある古い情報もあるが，新しいAngstromのイメージに更新してあるので，ボタンを押さなくてもSDカードに入っているOSが勝手に起動する．&lt;/p&gt;

&lt;p&gt;とりあえずBBBにSSHでログインする．&lt;/p&gt;
ssh ubuntu@192.168.7.2

&lt;p&gt;BBBと母艦PCをUSBでつなげるとアドレスは192.168.7.2になる．デフォルトのユーザー名は「ubuntu」，パスワードは「temppwd」になっている．&lt;/p&gt;

&lt;p&gt;さて，以上でインストールしたUbuntuはX window systemが含まれないリモートで操作することが想定されたイメージであった．（ubuntu-14.04-consoleとある）&lt;/p&gt;

&lt;p&gt;今後OpenCVを用いた画像処理等を行っていきたいと考えているので，デスクトップがあるのが好ましい．そこで，BeagleBoneBlackでもストレスなく動くような軽量なWindow systemである，LXDEを入れることにした．&lt;/p&gt;

&lt;p&gt;以下のサイトを参考にして作業を進める．
&lt;a href=&#34;http://elinux.org/Beagleboard:Installing_LXDE#LXDE_On_A_Micro_SD_with_Ubuntu_Raring&#34;&gt;http://elinux.org/Beagleboard:Installing_LXDE#LXDE_On_A_Micro_SD_with_Ubuntu_Raring&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;BBBにLXDE関係のものをインストールして再起動する．&lt;/p&gt;
sudo apt-get -y install lxde lxde-core lxde-icon-theme
sudo reboot

&lt;p&gt;さてここで，BeagleBoneBlackにHDMIケーブルを繋いでディスプレイを見てみると，残念なことに何も表示されない．LXDEが無くてもログイン画面は表示されるらしいが，それも表示されない．何が悪いのか分からないが，ディスプレイとの相性もあってBBBではハマりやすい問題らしい．
結局解決できなかったので，諦めてVNCサーバーを使ってリモートデスクトップで運用することにした．考えてみるとBBBにディスプレイが専有されないからこちらのほうが便利である．&lt;/p&gt;

&lt;p&gt;BBBにvncserverをインストールし，一旦起動して設定ファイルを生成する．初回起動時にはVNCでアクセスするためのパスワードを設定するように言われる．&lt;/p&gt;
sudo apt-get install vnc4server
vncserver
vncserver -kill :1

&lt;p&gt;~/.vnc/xstartupにある，設定ファイルをLXDE向けに以下のように編集する．&lt;/p&gt;
# !/bin/sh

# Uncomment the following two lines for normal desktop:
# unset SESSION_MANAGER
# exec /etc/X11/xinit/xinitrc

/usr/bin/lxsession &amp;

[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup
[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresources
xsetroot -solid grey
vncconfig -iconic &amp;
x-terminal-emulator -geometry 80x24+10+10 -ls -title &#34;$VNCDESKTOP Desktop&#34; &amp;
x-window-manager &amp;

&lt;p&gt;設定が終わればvncserverを立ち上げる&lt;/p&gt;
vncserver :1 -geometry 1024x768

&lt;p&gt;そして母艦のほうでBBBにリモートデスクトップ接続する．
リモートデスクトップクライアントにはRemminaを使った．&lt;/p&gt;
sudo apt-get install remmina
remmina

&lt;p&gt;新規リモートデスクトップの作成で，VNC用の設定する．アドレスではVNCのポート：5901を指定する．VNCのパスワードとかも入れる．
&lt;a href=&#34;http://syundo0730.github.io/images/2014/10/5a8c200f943d785a7efdf8d57fa3fd99.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-1027&#34; src=&#34;http://syundo0730.github.io/images/2014/10/5a8c200f943d785a7efdf8d57fa3fd99.png&#34; alt=&#34;スクリーンショット 2014-10-16 21.20.09&#34;   /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;そうするとこんな感じでBBBの中のデスクトップを見ることができた．
&lt;a href=&#34;http://syundo0730.github.io/images/2014/10/ebc1490b3de746708328967224fac359.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-1028&#34; src=&#34;http://syundo0730.github.io/images/2014/10/ebc1490b3de746708328967224fac359.png&#34; alt=&#34;スクリーンショット 2014-10-16 21.30.31&#34;   /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;おわり．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>